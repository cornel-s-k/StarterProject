/* eslint-disable no-restricted-globals */

import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkOnly } from 'workbox-strategies'; // Import NetworkOnly
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';

// Precache all assets generated by webpack
precacheAndRoute(self.__WB_MANIFEST);

// Cache pages using NetworkFirst strategy
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'pages-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache static assets (CSS, JS, images) using StaleWhileRevalidate
registerRoute(
  ({ request }) => request.destination === 'style' ||
                   request.destination === 'script' ||
                   request.destination === 'image',
  new StaleWhileReRevalidate({
    cacheName: 'static-assets-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 Days
      }),
    ],
  })
);

// Cache GET requests to API for stories using CacheFirst strategy
registerRoute(
  ({ url, request }) => url.pathname.startsWith('https://story-api.dicoding.dev/v1/stories') && request.method === 'GET',
  new CacheFirst({
    cacheName: 'api-stories-get-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 1 * 24 * 60 * 60, // 1 Day
        maxEntries: 50,
      }),
    ],
  })
);

// Do NOT cache POST requests to API. Use NetworkOnly for POST requests.
registerRoute(
  ({ url, request }) => url.pathname.startsWith('https://story-api.dicoding.dev/v1/stories') && request.method === 'POST',
  new NetworkOnly({
    // POST requests are generally not cacheable. This ensures they always go to the network.
  })
);


self.addEventListener('install', (event) => {
  console.log('Service Worker: Installed');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('Service Worker: Activated');
});

self.addEventListener('fetch', (event) => {
  // Workbox handles most of the fetching. Custom logic can be added here if needed.
});

self.addEventListener('push', (event) => {
  console.log('Service Worker: Push received!');
  const data = event.data ? event.data.json() : {};
  const title = data.title || 'Push Notification';
  const options = {
    body: data.message || 'You have a new notification!',
    icon: '/images/icons/icon-192x192.png',
    badge: '/images/icons/icon-72x72.png',
  };

  event.waitUntil(self.registration.showNotification(title, options));
});